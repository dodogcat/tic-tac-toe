인터페이스의 default 로 정석적인 틱택토 게임할 때 사용되는 매소드를 만들고,
static은 게임의 일부를 변경해도 달라지지 않을 것 같은 매소드를 만들었습니다.

객체의 정보가 필요한 경우 추상 매소드를 사용해 클래스에서 구현시켰습니다.


SOLID 원칙에 맞게 설계했나 자체 평가를 해봤습니다.

SPR : 하나의 클래스가 하나의 책임을 가진다.
사실 원칙을 알것 같으면서도 잘 모르기 때문에 혼란스러운 코딩이 됐다고 생각합니다.

이 프로그램의 클래스를 보자.
Horse - 정보만 담고 역할이 없기에 책임도 없다.
Man - 보드를 보는 역할을 하고 있다.
PlayMan - 사용자의 입력을 받아 Horse를 만들고 보드에 두고 있다. Man을 상속받았다.
SideMan - 다음 사용자를 선정하고 게임이 끝나는지 확인한다. Man을 상속받았다.
Gameboard - 들어온 Horse에 따라 보드의 값을 변경한다.

Man을 상속한 이유 - 현실에서 게임을 한다면 사람의 눈으로 게임 판을 보기 때문에 사람에 보드를 보는 역할을 넣고 상속을 사용했습니다.
                  약간 비효율적이라 생각이 들었지만 게임이 통신 대전 게임으로 변경될 경우 유용할수도 있을 거라 생각해 남겼습니다.

PlayMan 은 플레이어로서 적절한 책임을 지고 있다고 생각합니다.
SideMan 은 다음 플레이어를 뽑는 것과 게임이 끝나는지 확인하는 것으로 나누는 것이 좋아보이지만
           두가지 모두 현실의 규칙(심판)이 하는 역할이라 생각해 합쳐 놓았습니다.


OCP : 개방 폐쇄 원칙
보통 인터페이스를 통해 해결한다는데 이 프로그램에서는 Man 확장 말고는 예시가 안보인다.
잘 확장되나 폐쇄가 잘 되는지는 모르겠습니다.


LSP : 리스코프 치환 원칙
상속을 해도 상위 클래스의 역할을 할 수 있어야 한다.
PlayMan, SideMan은 둘다 Man의 역할을 잘 수행한다고 생각합니다.


ISP : 인터페이스 분리 원칙
자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
이 프로그램의 인터페이스들은 하나의 클래스를 위해 만들어졌기 때문에 문제가 되지 않는다.

하지만 Man의 인터페이스인 viewBoard는 SideMan 에서만 사용되고 있습니다.
현실에서는 플레이어와 심판 둘다 사람이기 때문에 필요하다고 생각했지만 구현에서는 심판만 viewBoard를 이용하기 때문에
Man에서 viewBoard 인터페이스를 없애는 것이 좋아보입니다.
그래도 혹시 'Man을 상속한 이유' 처럼 확장할 때 필요해보여 남겨두었습니다.

하나의 클래스를 위한 인터페이스를 만들다보니 인터페이스가 무거워진 느낌인데 이후를 위해
많은 인터페이스로 나눠서 구현해야했나 생각이 듭니다.

DIP : 의존성 역전 원칙
추상적인것은 저차원에 의존하면 안된다.
인터페이스를 통해 소통하기 때문에 어느정도 해결했다고 생각합니다.


기타 질문
1. 2차원 배열의 행, 열의 크기는 length를 통해 구할수 있는데 클래스에 변수로 사용하는것은 낭비인가요?
2. 인터페이스를 사용하면 클래스에는 변수 위주로 있게 되는건가요?
3. SRP 와 ISP를 생각하면 최대한 작은 단위로 만들고 사용하는 것들을 합치는게 좋아보이는데 이렇게 이해하는게 맞나요?
4. SOILD 원칙을 잘 지킨 코드를 어디서 참고할 수 있나요?
